# string 基础知识

[TOC]

## 比特和字节相关的概念

在计算机的世界中, 所有的数据都是按照 byte (字节) 来存储和计算的, 字节不是最小的存储单位, 最小的存储单位是 bit (比特), 但是最小的识别和计算单位是字节, 因此更大的数据单位都是基于字节来定义的。KB, MB, GB, TB 中的 "B" 都指的是 byte, 而不是 bit。这些单位之间的倍数关系如下:

+ 1 byte = 8 bits
+ 1 TB = 1024 GB = 1024 \* 1024 MB = 1024 \* 1024 \* 1024 KB = 1024 \* 1024 \* 1024 \* 1024 bytes

也就是说, byte, KB, MB, GB, TB 这些单位之间的倍数差是 1024。实际的情况是计算机按照 1024 的倍数差去计算, 而硬盘实际却是按照 1000 的倍数差去生产的, 导致电脑显示的硬盘空间小于硬盘制造商宣传的大小。我们实际在估算文件大小的时候也可以用 1000 的倍数差去估算, 如果电脑上显示的文件大小是 "12,636,660KB", 那么我们可以估算其大小大约为 12 GB。

## 字符的基本概念

有了比特和字节的概念后, 我们在其中怎么存储数据就要根据数据类型的特点来定义。基础的数据类型只有三种: int (整形), float (浮点) 和 char (字符)。整形的存储涉及到负数的表示, 浮点的存储涉及到指数位的定义和精度的问题, 这里我们就不进行讨论了, 我们重点来讨论字符的存储。

字符编码最简单的形式就是做一张映射表, 将每一个图形字符映射到一个整数上, 然后存储映射后的整数即可。将字符映射成一个整数的过程被称为 "字符编码", 映射表被称为 "编码集", 整数被称为 code point。注意: 字符存储实际的过程很复杂, 需要考虑存储空间的大小, 存储后是否方便解码, 能否在编码后的数据上进行字符串的搜索等等问题, 因此 code point 不是直接按照整形 (int) 存在磁盘中的。

不同语言编码所需要的字符量是不同的, 英文需求的字符量很少, ASCII 用 128 个整形就编码完成了, 因此只用 1 个字节就可以表示完成所有的字符, 中文需求的字符量很大, GBK 用 2 个字节才表示完成所有的字符。不同程序用不同的编码集会有兼容性问题, 如果使用错误的编码集那么就会出现 "乱码" 的问题, 这时候就需要一个统一的编码集 unicode。

unicode 是一个编码集, 包含了超过一百万个字符, 尽可能地将各种语言中的字符都包含了。为了存储效率, 针对 unicode, 又设计了不同的编码集, 包括 UTF-8, UTF-16, UTF-32。换句话说, UTF-8, UTF-16 和 UTF-32 是 unicode 的子集或者说是 unicode 的不同实现。

## Python 中的字符串

在 Python3 中, 有两种类型类型的字符串, 分别是 `str` (unicode string) 和 `bytes` (bytes string)。`str` 对象支持所有的 unicode 字符, 超过一百万种, 也是我们一般使用的字符串, 其最大 code point 可以通过 `sys.maxunicode` 来查看。

关于 `bytes`, 有两种身份: 字节数组 和 字节字符串。其本质就是字节数组, 我们可以将各种类型的数据转化为 `bytes` 对象:

+ `int` -> `bytes`: `(1).to_bytes(4, byteorder="little", signed=False)`
+ `float` -> `bytes`: `struct.pack("<f", 1.23)`
+ `str` -> `bytes`: `"木大".encode("gbk")`

1 个字节能存储的数据有: `bool`, `int8`, `uint8` 和 `char`。Python 的 `bytes` 对象输出和迭代兼容了 `char` 和 `uint8` 两种类型:

+ 如果迭代 `bytes` 对象, 会得到 `int` 对象, 值的范围是 [0, 255]
+ 如果输出 `bytes` 对象, 会将其当作 ASCII 字符串输出, 规则如下:
  + 如果输出字节对应的 `uint8` 小于 128, 那么就按照 ASCII 字符集中定义的输出
  + 如果输出字节对应的 `uint8` 大于或等于 128, 那么就按照通用转义字符 (以 `\x` 开头)来输出 (关于通用转义字符见下一小节)

示例代码如下:

```python
str_ = "欧拉 vs 木大"
bytes_ = str_.encode("utf-8")

print(str_)
print(bytes_)
print(list(str_))
print(list(bytes_))
```

当然了, 对应的也有以下两种创建 `bytes` 对象的方式:

+ 内置的 `bytes` 函数, 参数为 `Iterable[int]`, 比方说: `bytes([55, 100, 150, 200, 250])`, 注意所有整数的值不能超过 255
+ 在字符串前加上 `b` 前缀, 比方说: `b"apple \xff \x9a"`, 注意此时只接受 ASCII 中的字符和所有以 `\x` 开头的通用转义字符

由于 Python3 中的 `bytes` 对象是 Python2 中的 `str` 对象, 为了兼容 Python2, Python 3 中的 `bytes` 对象也提供了 `str` 对象的接口, 此时可以将 `bytes` 对象看成是字符串, 称为 bytes string。bytes string 的 code point 的范围是 [0, 255]: 如果 code point 的范围在 [0, 127] 之间, 则使用 ASCII 字符集, 如果 code point 的范围在 [128, 255] 之间, 则使用以 `\x` 开头的通用转义字符。

一般情况下, 我们使用 `bytes` 对象是将其当作字节数组来使用, 主要用于数据的存储和传输, 不会将其当作字符串来使用; 在使用字符串时, 会直接使用 `str` 对象 (unicode string)。

Python 中提供了 `chr` 和 `ord` 方法实现 code point 和 char 之间的相互转换。我们可以通过 `ord` 方法来查看字符的 code point, 可以通过 `chr` 将 code point 转化为字符, eg. `ord("天")`, `ord(b"A")`

在 `str` 和 `bytes` 的转化中, `bytes` 指的是字节数组, 也就是说:

+ 字符串**编码**成字节数组, eg. `"天".encode("utf-8")`
+ 字节数组**解码**成字符串, eg. `b"\xe5\xa4\xa9".decode("utf-8")`

我们可以将 `str` 理解为实际使用的, 人能理解的东西, 而 `bytes` 是人不能理解的, 电脑用于传输的东西。**编码** 的意思就是将 人能够理解的东西 变成 电脑能够理解或者传输的东西, **解码** 则相反。

## 转义字符

字符所表示的含义多种多样, 有一些字符是不可打印的字符, 比方说换行符, 制表符等等。为了方便输入, 就需要用其它的形式来表示。一般情况下, 用 `\n` 来表示换行符, 用 `\t` 来表示制表符, 这样的字符被称为转义字符 (escape char)。那如果不希望转义, 就是需要反斜杠 + n 怎么办呢? 可以用 `\\n` 或者 `r"\n"` 来表示。Python 中和所有转义字符的形式可以在 [escape sequences](https://docs.python.org/3/reference/lexical_analysis.html#escape-sequences) 中找到, 如果希望所有字符都不转义, 则给字符串添加 `r` 前缀。

更广义地说, 转义字符就是用特定的字符串组合来表示某种特殊的含义。比方说, 在 JSON 中, 双引号 `"` 用来表示字符串的开始和结束, 如果在字符串中需要双引号, 则需要加上反斜杠, 用 `\"` 来表示, 如果字符串中需要反斜杠, 则用双反斜杠 `\\` 来表示。在存储时 `\"` 和 `\\` 都是两个字符, 但是只会解析成一个字符。那么 `\"` 和 `\\` 都被称为转义字符。

不同的文件格式一般会定义自己的转义字符, 上面说了 JSON 中的部分转义字符, HTML 中也有自己的转义字符, 比方说在 HTML 中, `<` 表示某一个标签的起始, 如果想在页面上展示这个字符, 则需要转义成 `&lt;`。我们在写正则表达式时, 往往会给字符串添加 `r` 前缀, 因为其有自己的转义系统, 不需要 Python 原生的转义系统。

除了常见的 `\n`, `\t`, `\r` 外, Python 还额外支持一套通用转义字符系统, 可以用来表示任意的字符, 用十六进制的整数来表示:

+ `\x` + 两位十六进制字符, eg. `\x5A` 表示 `Z`, 最多可以表示 256 个不同的字符, 最大支持为 `\xff`
+ `\u` + 四位十六进制字符, eg. `\u6b27` 表示 `欧`, 最多可以表示 65536 个不同的字符, 最大支持为 `\uffff`
+ `\U` + 八位十六进制字符, eg. `\U0001f917` 表示 `🤗` (HuggingFace), 最大支持到 `\U0010ffff`

对于那些不可打印, 且没有特定转义字符的字符, Python 都会用通用转义的方式来输出。

额外补充, 如果想要输出整数的十六进制, 用 `%x`, 如果想要输出八进制, 用 `%o`, 可以配合地来记忆, 不要记混。

## encoding declaration

很多 Python 代码文件的开头会写 `# -*- coding:utf-8 -*-`, 其表示的含义是这个代码文件是用 `utf-8` 编码的。在 Python 2 中, 默认的代码文件编码方式为 `ascii`, 在 Python 3 中, 默认的代码文件编码方式为 `utf-8`, 如果文件的编码方式为其它, 需要在代码文件开头处申明。注意不要将代码文件的编码方式和 unicode string 的概念混淆在一起。官方文档参考: [encoding declaration](https://docs.python.org/3/reference/lexical_analysis.html#encoding-declarations) 。
